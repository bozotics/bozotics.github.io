---
title: General Information
permalink: /open/cam/general/
toc: true
toc_sticky: true
toc_icon: "cog"
toc_label: "General Information"
---

## Camera Microprocessor

### Raspberry Pi (RPi) 3B 

This model of RPi is the choice of our microprocessor for the camera system of our robot. The computational power of the RPi to its price is higher than other SBCs. Furthermore, the RPi has a well established community online which had been helpful when we faced issues with it. Aside from RPi 3B, we have also considered other alternatives. 

### Alternatives considered

<ins>Raspberry Pi 4B</ins>

The newer model of RPi was released in June 2019. By then, we had a few RPi 3Bs in our possession, thus it will be a waste to invest in new RPi 4Bs. Furthermore, since the RPi had just been released, there might be hardware or software issues. We did not want to take the risk of running into such problems, so we took the safe route of sticking with RPi 3B. 

<ins>Other SBCs</ins>

The $99 price tag of a **Jetson Nano** is more than 3 times that of a RPi. Furthermore, we were unsure of its performance and our ability to get the it working to our standards. Other than the Jetson Nano, we took the **Asus Tinkerboard** into consideration and experimented with it. However, our preliminary testing of the board gave us bad results as the images captured from the camera were distorted after passing through the graphics pipeline. This was made worse by the fact that there wasn't much online support and documentation for this board. While these SBCs could potentially have greater performance benefits, but chose settle on RPi which was "good enough" so that we can invest more time in other parts of the robot. 

<ins>RPi Compute Module</ins>

While the compute module could potentially make way for a more compact design of our robot, we did not use it due to the unreliability of our PCB during the time of consideration (when we first started designing PCBs). Also, similar to the RPi 4B, we did not want to put the existing RPi 3Bs in our possession to waste so we did not convert to compute modules. 

## Camera

### RPi camera V1

Currently, we are using RPi camera V1 which is able to capture frames at 640p and 90 FPS. Due to the inferior onboard camera sensor compared to its successor, we had to tune various camera parameters such as white balance, constrast, brightness, etc to exxagerate certain colours on the field to compensate for the lower quality images. 

### Alternatives considered

<ins>RPi camera V2</ins>

While this model of the RPi camera boasts a better sensor, the FPS cap for full FOV streaming was a dealbreaker. We tried to circumvent this problem by modifying the raspiraw library but to no avail. This plan was then abandoned as it was taking longer than expected and we found an alternative solution to this problem - adjusting the paramenters of V1. 

<ins>OpenMV</ins>

OpenMV was an enticing product for us as it had everything in place, from a GUI to the algorithms itself. However, we decided not to use it as it was extremely restrictive in terms of the algorithms. Furthermore, in the aspect of performance, OpenMV does not fare any better than the RPi. 

<ins>ArduCam</ins>

## Operating System (OS)

### Arch Linux

With Arch, the startup time of our RPi is around 12 seconds and if no program is running on the RPi, the CPU and RAM utilisation is close to 0%. To achieve that we only installed essential components and run the RPi headless (we do have an installed user interface which was used during set up). This was how we set up our RPi with Arch Linux:  

1. Write [Arch Linux Arm for Raspberry Pi 3](http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-3-latest.tar.gz) image into an SD card
2. Set-up autologin
3. Install Desktop environment preferably a lightweight one (LXDE) due to the limited RAM of the rpi (Optional)
4. Obtain SSH public keys on both devices (laptop and rpi)
5. Set up DHCP server on rpi (Allow RPi to assign the laptop a static IP address)
6. Install OpenCV with optimization (ARM NEON and VFPV3 enabled)
7. Also install the following packages: libssh and raspicam (modified)

### Alternatives considered

<ins>Raspbian (Lite)</ins>

Initially when we first started using RPi, we used Raspbian. However, we thought the 30 seconds startup was too long for us and at any point of time there were many background processes running, thus draining the limited computational resources. 

<ins>Diet Pi</ins>

<ins>Buildroot</ins>

<ins>Bare Metal</ins>

## Programming Language

All of our code is written in C++ as it is more suited for our use of running programs in realtime. In previous years, we used Python but aftering uncovering problems such as slower computational speed and the Global Interpreter Lock, we made a switch to C++. 

## Libraries Used

These are some libraries that we used in the development of our camera program and GUI.

### "`OpenCv`"

`OpenCV` was used for image transformation and processing as it contains a wide range of well documented computer vision algorithms. We built the `OpenCV` with all available optimisations for RPi. With these optimisations, the performance increased by 400 percent (Most functions are 4 times faster).    

### "`LibSSH`" (modified)

[link to source code](google.com)

`LibSSH` was used to access the files in the raspi from the laptop. It played an essential part in the automation of sending files, running programs and running commands on the terminal of the RPi in our GUI.

### "`Threading`"

Task parallelisation was achieved with this library. We used atomic variables and conditions to control and synchronise multiple threads. `Threading` in C++ allowed us to achieve true task parallelisation instead of rapid task switching in Python. 

### "`QT5`"

Our GUI was created using this library - from the design to functions. 

<details markdown=1><summary>todo</summary>

- camera+raspi
  - vs other SBC (jetson nano, tinkerboard, odroid)
  - vs compute module
  - vs raspi 4
  - SD card woes + backup problems
  - initial confusions, python opencv era of reinstalling 100000 times
  - OS considered
    - raspbian (lite)
    - dietpi
    - arch
    - buildroot and why we haven't done that yet
    - bare metal and why we also didn't do that (yet???)
  - include other cameras considered from arducam + issues with V2

</details>
